// SPDX-FileCopyrightText: 2024 Cesanta Software Limited
// SPDX-License-Identifier: GPL-2.0-only or commercial
// Generated by Mongoose Wizard, https://mongoose.ws/wizard/, edited by Adam Valt

#include "stm32h7xx_hal.h"
#include "mongoose_glue.h"
#include "flashing_history.h"
#include "flash_over_can.h"
#include "remote_reboot.h"
#include "boards.h"
#include "globals.h"
#include "errors.h"
#include "Canopen_Main.h"

void can_open_process(CO_t *CO) {
    CANOpenProcess(CO, HAL_GetTick());
}

void glue_init(void) {
    MG_DEBUG(("Custom init done"));
    mg_timer_add(&g_mgr, 1, MG_TIMER_REPEAT, (void (*)(void *)) can_open_process, CanOpenCrit);
//    mg_timer_add(&g_mgr, 1, MG_TIMER_REPEAT, (void (*)(void *)) can_open_process, CanOpenGen);
    mg_timer_add(&g_mgr, 5000, MG_TIMER_REPEAT, (void (*)(void *)) update_boards_state, NULL);
    mg_timer_add(&g_mgr, 1000, MG_TIMER_REPEAT, (void (*)(void *)) remove_errors_periodic_check, NULL);
    mg_timer_add(&g_mgr, REPEATED_SDO_DELTA_TIME_MS, MG_TIMER_REPEAT, (void (*)(void *)) periodic_can_flash, NULL);
}

// username saved for the purposes of saving it to history entry
char username[32] = {0};

// Authenticate user/password. Return access level for the authenticated user:
//   0 - authentication error
//   1,2,3... - authentication success. Higher levels are more privileged than lower
int glue_authenticate(const char *user, const char *pass) {
    strcpy(username, user);
    int level = 0; // Authentication failure
    if (strcmp(user, "admin") == 0 && strcmp(pass, "admin") == 0) {
        level = 7;  // Administrator
    } else if (strcmp(user, "user") == 0 && strcmp(pass, "user") == 0) {
        level = 3;  // Ordinary dude
    }
    return level;
}

void *glue_file_open_file_upload(char *file_name, size_t total_size) {
    s_flashing.size = total_size;
    strcpy(s_flashing.filename, file_name);
    glue_update_state();
    mg_save_file_begin(total_size);
    return (void *) MG_FILESAVE_FLASH_ADDRESS;
}

bool glue_file_close_file_upload(void *fp) {
    bool ok = mg_save_file_end();
    s_flashing.crc = mg_crc32(0, (char *) MG_FILESAVE_FLASH_ADDRESS, s_flashing.size);
    MG_DEBUG(("File uploaded to address: %p with length: %d CRC: %x and status: %s", fp, s_flashing.size, s_flashing.crc, ok ? "ok" : "fail"));
    if (!ok) {
        strcpy(s_flashing.error, "File upload failed, try again.");
        strcpy(s_flashing.filename, "No file uploaded");
        glue_update_state();
    }
    return ok;
}

bool glue_file_write_file_upload(void *fp, void *buf, size_t len) {
    MG_VERBOSE(("writing fp %p %p %lu bytes", fp, buf, len));
    return mg_save_file_write(buf, len);
}

void glue_get_state(struct state *data) {
    *data = s_mongoose_state;
}

void glue_set_state(struct state *data) {
    s_mongoose_state = *data;
}

void glue_get_security(struct security *data) {
    *data = s_security;
}

void glue_set_security(struct security *data) {
    s_security = *data;
}

void glue_reply_boards(struct mg_connection *c, struct mg_http_message *hm) {
    const char *headers = "Cache-Control: no-cache\r\n" "Content-Type: application/json\r\n";
    char json[4000] = {0};
    get_boards_state_json(json, 4000);
    MG_VERBOSE(("%s", json));
    (void) hm;
    mg_http_reply(c, 200, headers, "%s\n", json);
}

static uint64_t s_action_timeout_reboot;  // Time when reboot ends
bool glue_check_reboot(void) {
  return s_action_timeout_reboot > mg_now(); // Return true if reboot is in progress
}

void glue_start_reboot(struct mg_str params) {
  MG_DEBUG(("Passed parameters: [%.*s]", params.len, params.buf));
  bool ok = remote_reboot(board_name_to_board_index(params.buf));
  if (ok) {
    s_action_timeout_reboot = mg_now() + NODE_REBOOT_MINIMUM_TIME_MS;
  }
}

void glue_get_flashing(struct flashing *data) {
  *data = s_flashing;  // Sync with your device
}
void glue_set_flashing(struct flashing *data) {
    s_flashing = *data; // Sync with your device
}

// returns true when the flashing process is still ongoing
bool glue_check_flashing_action(void) {
    return s_flashing.state == NODE_IN_BOOTLOADER || s_flashing.state == FLASHING_IN_PROGRESS || s_flashing.state == NODE_RESETTING;
}

void glue_start_flashing_action(struct mg_str params) {
    MG_DEBUG(("Passed parameters: [%.*s]", params.len, params.buf));
    char timestamp[32];
    int n = sprintf(timestamp, "%lld", (long long) mg_now());
    timestamp[n] = '\0';

    save_flashing_history_entry(s_flashing.selected_board, s_flashing.new_version, timestamp, s_flashing.filename, username, "OK" );
    flashing_start();
}

void glue_reply_flashing_history(struct mg_connection *c, struct mg_http_message *hm) {
  const char *headers = "Cache-Control: no-cache\r\n" "Content-Type: application/json\r\n";
  char json[4000] = {0};
  get_flashing_history_json(json, 4000);
  MG_VERBOSE(("%s", json));
  (void) hm;
  mg_http_reply(c, 200, headers, "%s\n", json);
}